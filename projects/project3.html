<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D3 US Earthquakes — Left Sidebar Filters (Aligned)</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
<style>
  :root { --bg:#0b0e14; --text:#e8eef7; --muted:#9fb0c6; --grid:#243142; --accent:#1f62d6; }

  *{ box-sizing:border-box }
  body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; height:100vh; overflow:hidden }

  header{ height:52px; display:flex; align-items:center; gap:10px; padding:0 12px; border-bottom:1px solid var(--grid); white-space:nowrap; overflow:hidden }
  header h1{ font-size:16px; margin:0; font-weight:600 }
  header .sub{ color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis }

  /* --- Layout: left sidebar + map view --- */
  .layout{ position:absolute; inset:52px 0 0 0; display:grid; grid-template-columns: 300px 1fr; gap:0 }
  @media (max-width:900px){ .layout{ grid-template-columns: 260px 1fr; } }

  .sidebar{
    border-right:1px solid var(--grid);
    background:rgba(15,20,28,.9);
    padding:12px 10px;
    overflow:auto;
  }
  .filters{ display:grid; grid-template-columns:1fr; gap:14px }
  .section{ display:grid; grid-template-columns:1fr; gap:8px; padding-bottom:6px; border-bottom:1px dashed #1c2837 }
  .section:last-child{ border-bottom:none; }
  .row{ display:grid; grid-template-columns:90px 1fr; gap:8px; align-items:center }
  .label{ color:var(--muted); font-size:12px }
  .valuespan{ color:var(--muted); font-size:12px; font-variant-numeric:tabular-nums }
  input[type="number"]{ background:#0f141c; color:var(--text); border:1px solid var(--grid); border-radius:6px; padding:4px 6px; width:90px }

  /* Native dual-handle slider (stacked range inputs) */
  .slider2{ position:relative; height:38px; display:flex; align-items:center; grid-column: 1 / span 2 }
  .slider2 input[type="range"]{
    -webkit-appearance:none; appearance:none;
    position:absolute; width:100%; background:none; pointer-events:none;
  }
  .slider2 input[type="range"]::-webkit-slider-runnable-track{
    height:8px; border-radius:999px; background:#dfe8f6;
  }
  .slider2 input[type="range"]::-moz-range-track{
    height:8px; border-radius:999px; background:#dfe8f6;
  }
  .slider2 input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none;
    width:16px; height:16px; border-radius:50%;
    background:#ffffff; border:2px solid var(--accent);
    margin-top:-4px; pointer-events:auto;
  }
  .slider2 input[type="range"]::-moz-range-thumb{
    width:16px; height:16px; border-radius:50%;
    background:#ffffff; border:2px solid var(--accent); pointer-events:auto;
  }
  .slider2 input.lower{ z-index:1 }
  .slider2 input.upper{ z-index:2 }

  /* Align Min/Max rows flush under the slider (no left label column) */
  .row.values{ grid-template-columns: 1fr; }
  .row.values .label{ display:none; }

  /* Consistent grid for Min / (middle cell) / Max on one line */
  .valuebox{
    display:grid;
    grid-template-columns: auto 90px 1fr auto 90px; /* "Min" label, input, middle (spacer/checkbox), "Max" label, input */
    align-items:center;
    gap:8px;
    color:var(--muted);
    font-size:12px;
  }
  .valuebox input[type="number"]{ width:90px }

  .view{ position:relative }
  svg{ width:100%; height:calc(100%); display:block }

  .states{ fill:#0d1320; stroke:#2a3a52; stroke-width:.6 }
  .state-borders{ fill:none; stroke:#2a3a52; stroke-width:.6; pointer-events:none }
  .quake{ stroke:#000; stroke-opacity:.45 }
  .nodata{ fill:#9aa0a6 !important; opacity:.9 }

  .legend-card{ fill:rgba(10,14,20,.9); stroke:var(--grid); stroke-width:1; filter:drop-shadow(0 8px 16px rgba(0,0,0,.35)); rx:10; ry:10 }
  .legend-title{ fill:#9ad1ff; font-weight:600; font-size:12px }

  .tooltip{ position:absolute; pointer-events:none; opacity:0; background:#0d1320; color:var(--text); border:1px solid var(--grid); padding:8px 10px; font-size:12px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); transform:translate(-50%,-120%) }
</style>
</head>
<body>
<header>
  <h1>US Earthquakes — Left Sidebar Filters</h1>
  <div class="sub">Size = magnitude, color = depth (km). Drag to pan & zoom. Filters on the left.</div>
</header>

<div class="layout">
  <!-- Sidebar filters -->
  <aside class="sidebar">
    <div class="filters">

      <!-- Magnitude -->
      <div class="section" id="magSection">
        <div class="row">
          <div class="label">Magnitude</div>
          <div class="valuespan" id="magVals">—</div>
        </div>
        <div class="slider2">
          <input id="magMinR" class="lower" type="range" step="0.1">
          <input id="magMaxR" class="upper" type="range" step="0.1">
        </div>
        <div class="row values">
          <div class="label"></div>
          <div class="valuebox">
            <span>Min</span><input id="magMinN" type="number" step="0.1">
            <span class="spacer"></span>
            <span>Max</span><input id="magMaxN" type="number" step="0.1">
          </div>
        </div>
      </div>

      <!-- Depth -->
      <div class="section" id="depthSection">
        <div class="row">
          <div class="label">Depth (km)</div>
          <div class="valuespan" id="depthVals">—</div>
        </div>
        <div class="slider2">
          <input id="depthMinR" class="lower" type="range" step="10">
          <input id="depthMaxR" class="upper" type="range" step="10">
        </div>
        <div class="row values">
          <div class="label"></div>
          <div class="valuebox">
            <span>Min</span><input id="depthMinN" type="number" step="10">
            <!-- middle cell holds the checkbox to keep alignment -->
            <label style="justify-self:center; display:flex; align-items:center; gap:6px; color:var(--muted);">
              <input id="includeNA" type="checkbox"> Include N/A depth
            </label>
            <span>Max</span><input id="depthMaxN" type="number" step="10">
          </div>
        </div>
      </div>

      <!-- Year -->
      <div class="section" id="yearSection">
        <div class="row">
          <div class="label">Year</div>
          <div class="valuespan" id="yearVals">—</div>
        </div>
        <div class="slider2">
          <input id="yearMinR" class="lower" type="range" step="1">
          <input id="yearMaxR" class="upper" type="range" step="1">
        </div>
        <div class="row values">
          <div class="label"></div>
          <div class="valuebox">
            <span>Min</span><input id="yearMinN" type="number" step="1">
            <span class="spacer"></span>
            <span>Max</span><input id="yearMaxN" type="number" step="1">
          </div>
        </div>
      </div>

      <div class="section" style="padding-top:4px;">
        <div class="label" style="opacity:.8;">Tip: click empty map to reset zoom.</div>
      </div>

    </div>
  </aside>

  <!-- Map + legend -->
  <div class="view">
    <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>
(async function () {
  const svg = d3.select("#svg");
  const zoomLayer = svg.append("g");
  const mapG = zoomLayer.append("g");
  const ptsG = zoomLayer.append("g");
  const legendG = svg.append("g");
  const tooltip = d3.select("#tooltip");

  function sizeSVG(){
    const r = document.querySelector(".view").getBoundingClientRect();
    svg.attr("viewBox", [0,0,r.width,r.height]);
    return { width:r.width, height:r.height };
  }
  let { width, height } = sizeSVG();
  window.addEventListener("resize", ()=>{ ({width,height}=sizeSVG()); drawLegend(); render(); });

  // Projection & map
  const projection = d3.geoAlbersUsa().translate([width/2, height/2]).scale(Math.min(width,height)*1.2);
  const path = d3.geoPath(projection);
  const us = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r=>r.json());
  const states = topojson.feature(us, us.objects.states);
  const borders = topojson.mesh(us, us.objects.states, (a,b)=>a!==b);
  mapG.append("path").datum(states).attr("class","states").attr("d", path);
  mapG.append("path").datum(borders).attr("class","state-borders").attr("d", path);

  // Data
  const data = await d3.csv("us_earthquakes_m4.5.csv", d=>{
    const depth = (d.depth===""||d.depth==null)?null:+d.depth;
    const mag   = (d.mag===""  ||d.mag==null)  ?null:+d.mag;
    const lat=+d.latitude, lon=+d.longitude;
    const year = d.time ? new Date(d.time).getUTCFullYear() : null;
    return { time:d.time, year, place:d.place||"", region:d.region||"", depth, mag, lat, lon };
  });
  const points = data.filter(d => isFinite(d.lat) && isFinite(d.lon));

  // Domains
  const depthVals = points.map(d=>d.depth).filter(v=>v!=null && isFinite(v));
  const depthExt  = d3.extent(depthVals.length ? depthVals : [0,700]);
  const dDomMin   = Math.max(0, Math.floor((depthExt[0] ?? 0)));
  const dDomMax   = Math.min(700, Math.ceil((depthExt[1] ?? 700)));

  const magVals = points.map(d=>d.mag).filter(v=>v!=null && isFinite(v));
  const magDom  = d3.extent(magVals.length ? magVals : [4.5,8]);

  const yearVals = points.map(d=>d.year).filter(y=>y!=null && isFinite(y));
  const yearDom  = d3.extent(yearVals.length ? yearVals : [1950, 2025]);

  const color = d3.scaleSequential([dDomMin, dDomMax], d3.interpolateTurbo);
  const size  = d3.scaleSqrt().domain(magDom).range([1.8, 11]);

  // UI state
  let magRange   = [magDom[0], magDom[1]];
  let depthRange = [dDomMin, dDomMax];
  let yearRange  = [yearDom[0], yearDom[1]];

  // Generic native dual-slider initializer
  function initDualNative({ domain, step, initial, ids, onChange, labelElId }){
    const lowerR = document.getElementById(ids.lowerRange);
    const upperR = document.getElementById(ids.upperRange);
    const lowerN = document.getElementById(ids.lowerNum);
    const upperN = document.getElementById(ids.upperNum);
    const label  = document.getElementById(labelElId);

    // configure min/max/step
    [lowerR.min, upperR.min, lowerN.min, upperN.min] = [domain[0], domain[0], domain[0], domain[0]];
    [lowerR.max, upperR.max, lowerN.max, upperN.max] = [domain[1], domain[1], domain[1], domain[1]];
    [lowerR.step, upperR.step, lowerN.step, upperN.step] = [step, step, step, step];

    const clamp = v => Math.min(domain[1], Math.max(domain[0], (step>=1? Math.round(v/step)*step : Math.round(v*10)/10)));

    function paintTrack(minV, maxV){
      const pct = v => 100 * (v - domain[0]) / (domain[1] - domain[0]);
      const g = `linear-gradient(to right,
        #dfe8f6 ${pct(domain[0])}%,
        var(--accent) ${pct(minV)}%,
        var(--accent) ${pct(maxV)}%,
        #dfe8f6 ${pct(domain[1])}%)`;
      lowerR.style.background = g;
    }

    function sync([lo, hi], notify=true){
      let minV = clamp(Math.min(lo, hi));
      let maxV = clamp(Math.max(lo, hi));
      lowerR.value = minV; upperR.value = maxV;
      lowerN.value = minV; upperN.value = maxV;
      paintTrack(minV, maxV);

      if (label){
        const fmt = step===0.1 ? (x=>(+x).toFixed(1)) : (x=>x);
        label.textContent = `${fmt(minV)} – ${fmt(maxV)}`;
      }
      if (notify) onChange([minV, maxV]);
    }

    // Events
    lowerR.addEventListener('input', ()=> {
      const lo = +lowerR.value, hi = +upperR.value;
      if (lo > hi) upperR.value = lo;
      sync([+lowerR.value, +upperR.value]);
    });
    upperR.addEventListener('input', ()=> {
      const lo = +lowerR.value, hi = +upperR.value;
      if (hi < lo) lowerR.value = hi;
      sync([+lowerR.value, +upperR.value]);
    });

    lowerN.addEventListener('change', ()=> {
      const lo = clamp(+lowerN.value), hi = clamp(+upperN.value);
      sync([lo, hi]);
    });
    upperN.addEventListener('change', ()=> {
      const lo = clamp(+lowerN.value), hi = clamp(+upperN.value);
      sync([lo, hi]);
    });

    // Initial paint
    sync(initial ?? domain, /*notify=*/true);
    return { set: (rng)=> sync(rng, true) };
  }

  // Initialize sliders
  const magCtrl = initDualNative({
    domain: magDom, step: 0.1, initial: magRange,
    ids: { lowerRange:'magMinR', upperRange:'magMaxR', lowerNum:'magMinN', upperNum:'magMaxN' },
    labelElId: 'magVals',
    onChange: (r)=>{ magRange = r; render(); }
  });

  const depthCtrl = initDualNative({
    domain: [dDomMin, dDomMax], step: 10, initial: depthRange,
    ids: { lowerRange:'depthMinR', upperRange:'depthMaxR', lowerNum:'depthMinN', upperNum:'depthMaxN' },
    labelElId: 'depthVals',
    onChange: (r)=>{ depthRange = r; render(); }
  });

  const yearCtrl = initDualNative({
    domain: yearDom, step: 1, initial: yearRange,
    ids: { lowerRange:'yearMinR', upperRange:'yearMaxR', lowerNum:'yearMinN', upperNum:'yearMaxN' },
    labelElId: 'yearVals',
    onChange: (r)=>{ yearRange = r; render(); }
  });

  // Legend (fixed)
  function drawLegend(){
    legendG.selectAll("*").remove();
    const pad=10, cardW=Math.min(260,Math.max(220,width*0.22)), cardH=110;
    const x0=width-cardW-12, y0=height-cardH-12;

    legendG.append("rect").attr("class","legend-card").attr("x",x0).attr("y",y0).attr("width",cardW).attr("height",cardH);

    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",y0+18).text("Depth (km)");

    const barW=cardW-pad*2, barH=12, gradId="depthGrad";
    const defs=legendG.append("defs");
    const grad=defs.append("linearGradient").attr("id",gradId).attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");
    const stops=12;
    for(let i=0;i<=stops;i++){
      const t=i/stops, val=dDomMin + t*(dDomMax-dDomMin);
      grad.append("stop").attr("offset",`${t*100}%`).attr("stop-color", color(val));
    }
    legendG.append("rect").attr("x",x0+pad).attr("y",y0+26).attr("width",barW).attr("height",barH)
      .attr("rx",6).attr("ry",6).attr("fill",`url(#${gradId})`).attr("stroke","#243142");
    const tickY=y0+26+barH+12;
    [dDomMin, Math.round((dDomMin+dDomMax)/2), dDomMax].forEach((t,i)=>{
      const tx = x0+pad + (barW * i/2);
      legendG.append("text").attr("x",tx).attr("y",tickY)
        .attr("text-anchor", i===0?'start':i===2?'end':'middle')
        .attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6')
        .attr("font-size",11).text(t);
    });

    const mags=[magDom[0], (magDom[0]+magDom[1])/2, magDom[1]].map(v=>+v.toFixed(1));
    const baseY=tickY+8;
    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",baseY+16).text("Magnitude");
    const cx0=x0+pad+72, gap=(cardW-pad-cx0-10)/(mags.length-1);
    mags.forEach((m,i)=>{
      const cx=cx0+i*gap, r=size(m);
      legendG.append("circle").attr("cx",cx).attr("cy",baseY+26).attr("r",r).attr("fill","#e6e6e6").attr("fill-opacity",.9)
        .attr("stroke","#000").attr("stroke-opacity",.4);
      legendG.append("text").attr("x",cx).attr("y",baseY+26+r+12).attr("text-anchor","middle")
        .attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6')
        .attr("font-size",11).text(m);
    });
  }

  function render(){
    const allowNA = document.getElementById("includeNA").checked;

    const filtered = points.filter(d=>{
      const magOK   = (d.mag  != null && d.mag  >= magRange[0]   && d.mag  <= magRange[1]);
      const yearOK  = (d.year != null && d.year >= yearRange[0]  && d.year <= yearRange[1]);
      const depthOK = d.depth == null ? allowNA : (d.depth >= depthRange[0] && d.depth <= depthRange[1]);
      return magOK && yearOK && depthOK;
    });

    const sel = ptsG.selectAll("circle.quake").data(filtered, (d,i)=>d.time+"|"+i);

    sel.enter().append("circle")
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      })
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("fill-opacity", .85)
      .on("mousemove", (event, d) => {
        const [x,y] = d3.pointer(event, document.querySelector(".view"));
        tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(`
          <div><b>${d.mag?.toFixed(1) ?? "M?"}</b> — <span style="color:var(--muted)">${d.place || d.region || "Location"}</span></div>
          <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
          <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
        `);
      })
      .on("mouseleave", ()=> tooltip.style("opacity", 0));

    sel
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      });

    sel.exit().remove();
  }

  drawLegend();
  render();

  // Zoom (legend fixed)
  const zoom = d3.zoom().scaleExtent([0.9, 8]).on("zoom", (ev)=> {
    zoomLayer.attr("transform", ev.transform);
  });
  svg.call(zoom).on("click", (e)=>{
    if (e.target === svg.node()) svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
  });

  // Include N/A toggle
  document.getElementById("includeNA").addEventListener("change", render);
})();
</script>
</body>
</html>
