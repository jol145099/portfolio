<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D3 US Earthquakes ‚Äî Stable Map + Multi-select Locations</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
<style>
  :root { --bg:#0b0e14; --text:#e8eef7; --muted:#9fb0c6; --grid:#243142; --accent:#1f62d6; --panel:#0f141c; }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden }

  header{ height:52px; display:flex; align-items:center; gap:10px; padding:0 12px; border-bottom:1px solid var(--grid); white-space:nowrap; overflow:hidden }
  header h1{ font-size:16px; margin:0; font-weight:600 }
  header .sub{ color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis }

  .layout{ position:absolute; inset:52px 0 0 0; display:grid; grid-template-columns: 340px 1fr; min-height:0 }
  @media (max-width:900px){ .layout{ grid-template-columns: 280px 1fr; } }

  .sidebar{ border-right:1px solid var(--grid); background:rgba(15,20,28,.94); padding:16px 14px; overflow:auto }
  .filters{ display:grid; gap:16px; min-width:0 }
  .section{ display:grid; gap:8px; padding-bottom:10px; border-bottom:1px dashed #1c2837 }
  .section:last-child{ border-bottom:none; }

  .row{ display:grid; grid-template-columns:90px 1fr; gap:4px; align-items:center }
  .label{ color:#e8eef7; font-size:14px }
  .valuespan{ color:var(--muted); font-size:12px; font-variant-numeric:tabular-nums }

  .slider2{ position:relative; height:26px; display:flex; align-items:center; grid-column: 1 / span 2 }
  .slider2 input[type="range"]{ -webkit-appearance:none; appearance:none; position:absolute; width:100%; background:none; pointer-events:none; }
  .slider2 input[type="range"]::-webkit-slider-runnable-track{ height:5px; border-radius:999px; background:#dfe8f6; }
  .slider2 input[type="range"]::-moz-range-track{ height:5px; border-radius:999px; background:#dfe8f6; }
  .slider2 input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:12px; height:12px; border-radius:50%; background:#ffffff; border:2px solid var(--accent); margin-top:-4px; pointer-events:auto; }
  .slider2 input[type="range"]::-moz-range-thumb{ width:12px; height:12px; border-radius:50%; background:#ffffff; border:2px solid var(--accent); pointer-events:auto; }
  .slider2 input.lower{ z-index:1 } .slider2 input.upper{ z-index:2 }

  .row.values{ grid-template-columns: 1fr; }
  .row.values .label{ display:none; }
  .valuebox{ display:grid; grid-template-columns: auto 65px 1fr auto 65px; align-items:center; gap:2px; color:var(--muted); font-size:11.5px; }
  
  input[type="number"]{ background:#0f141c; color:#e8eef7; border:1px solid var(--grid); margin-left: 5px; text-align: center; border-radius:6px; padding:3px 6px; width:60px; }
  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button {-webkit-appearance: none; margin: 0;}

  .checkboxrow {margin-left: 4px;}
  .checkboxrow label{ display:flex; align-items:center; gap:4px; color:var(--muted); font-size:11.5px; margin:0; }

  .locbox{ position:relative; display:grid; gap:8px; }
  .locbox input[type="text"]{ width:100%; padding:6px 8px; border-radius:6px; border:1px solid var(--grid); background:#0f141c; color:#e8eef7; min-width:0; }
  .helper{ color:var(--muted); font-size:11px }

  .chips{ display:flex; flex-wrap:wrap; gap:6px; }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; background:#101826; border:1px solid #233144; font-size:12px; }
  .chip .x{ cursor:pointer; opacity:.7; font-weight:700 }
  .chip .x:hover{ opacity:1 }

  .loc-suggest{ position:absolute; left:0; right:0; top: calc(100% + 4px); background:var(--panel); border:1px solid var(--grid); border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); max-height:240px; overflow-y:auto; z-index:20; display:none; }
  .loc-item{ padding:6px 8px; font-size:12px; color:#e8eef7; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; }
  .loc-item small{ color:var(--muted); font-size:11px; margin-left:6px }
  .loc-item:hover, .loc-item.active{ background:#162031; }

  .view{ position:relative; min-height:0 } /* allows svg to fill remaining height */
  svg{ width:100%; height:100%; display:block }

  .states{ fill:#0d1320; stroke:#2a3a52; stroke-width:.6 }
  .state-borders{ fill:none; stroke:#2a3a52; stroke-width:.6; pointer-events:none }
  .quake{ stroke:#000; stroke-opacity:.45 }
  .nodata{ fill:#9aa0a6 !important; opacity:.9 }

  .legend-card{ fill:rgba(10,14,20,.9); stroke:var(--grid); stroke-width:1; filter:drop-shadow(0 8px 16px rgba(0,0,0,.35)); rx:10; ry:10 }
  .legend-title{ fill:#9ad1ff; font-weight:600; font-size:12px }

  .tooltip{ position:absolute; pointer-events:none; opacity:0; background:#0d1320; color:#e8eef7; border:1px solid var(--grid); padding:8px 10px; font-size:12px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); transform:translate(-50%,-120%) }

  #resetBtn {width: 100%;padding: 8px 0; background-color: #1e2a3a; color: #cfe3ff; font-size: 13px; font-weight: 600; border: 1px solid #3b4a5c; border-radius: 6px; cursor: pointer; transition: all 0.2s ease-in-out;}

  #resetBtn:hover {background-color: #2b3c52; color: #ffffff; border-color: #4d6480;}

  #resetBtn:active {transform: scale(0.97);}

</style>
</head>
<body>
<header>
  <h1>US Earthquakes ‚Äî Interactive Map</h1>
  <div class="sub">Interactive D3.js map of U.S. earthquakes over the past 100 years (including Alaska, Hawaii & Puerto Rico/USVI). Each quake is a dot: larger for higher magnitude and color coded for depth. Hover tooltips to reveal details.</div>
</header>

<div class="layout">
  <aside class="sidebar">
    <div class="filters">

      <div class="section">
        <div class="row"><div class="label">Magnitude</div><div class="valuespan" id="magVals">‚Äî</div></div>
        <div class="slider2">
          <input id="magMinR" class="lower" type="range" step="0.1">
          <input id="magMaxR" class="upper" type="range" step="0.1">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="magMinN" type="number" step="0.1"><span></span><span>Max</span><input id="magMaxN" type="number" step="0.1"></div>
        </div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Depth (km)</div><div class="valuespan" id="depthVals">‚Äî</div></div>
        <div class="slider2">
          <input id="depthMinR" class="lower" type="range" step="10">
          <input id="depthMaxR" class="upper" type="range" step="10">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="depthMinN" type="number" step="10"><span></span><span>Max</span><input id="depthMaxN" type="number" step="10"></div>
        </div>
        <div class="checkboxrow"><label><input id="includeNA" type="checkbox"> Include N/A</label></div>
      </div>

      <div class="section">
        <div class="row"><div class="label">Year</div><div class="valuespan" id="yearVals">‚Äî</div></div>
        <div class="slider2">
          <input id="yearMinR" class="lower" type="range" step="1">
          <input id="yearMaxR" class="upper" type="range" step="1">
        </div>
        <div class="row values">
          <div class="valuebox"><span>Min</span><input id="yearMinN" type="number" step="1"><span></span><span>Max</span><input id="yearMaxN" type="number" step="1"></div>
        </div>
      </div>

      <div class="section">
        <div class="row">
          <div class="label">Location</div>
          <div class="valuespan helper">Add cities or States</div>
        </div>
        <div class="locbox">
          <input id="locInput" type="text" placeholder="Type: Los Angeles, CA ‚Ä¢ CA ‚Ä¢ California‚Ä¶" autocomplete="off">
          <div id="chips" class="chips"></div>
          <div id="locSuggest" class="loc-suggest"></div>
          <div class="helper">Click to add. Backspace on empty box removes last chip. ‚ÄúClear‚Äù removes all.</div>
        </div>
        <div class="row values">
          <div class="valuebox" style="grid-template-columns:auto auto;">
            <button id="clearLoc" style="background:#0f141c;color:#e8eef7;border:1px solid var(--grid);border-radius:6px;padding:4px 8px;cursor:pointer;">Clear</button>
          </div>
        </div>
      </div>

      <div class="section" style="padding-top:4px;">
        <div class="label" style="opacity:.85;">Note: Click empty map to reset zoom.</div>
      </div>

      <div class="section" style="margin-top: 10px;">
        <button id="resetBtn">üîÑ Reset Filters</button>
      </div>

    </div>
  </aside>

  <div class="view">
    <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>
(async function () {
  /* ---------- Small helpers ---------- */
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const safeExtent = (arr, fallback=[0,1]) => {
    if (!arr || !arr.length) return fallback.slice();
    const e = d3.extent(arr.filter(x => x!=null && isFinite(x)));
    if (e[0]==null || e[1]==null || isNaN(e[0]) || isNaN(e[1])) return fallback.slice();
    if (e[0]===e[1]) return [e[0], e[0]+(typeof e[0]==="number"?1:1)];
    return e;
  };

  /* ---------- State maps ---------- */
  const STATE_ABBR_TO_FULL = {
    AL:"Alabama", AK:"Alaska", AZ:"Arizona", AR:"Arkansas", CA:"California", CO:"Colorado",
    CT:"Connecticut", DE:"Delaware", FL:"Florida", GA:"Georgia", HI:"Hawaii", ID:"Idaho",
    IL:"Illinois", IN:"Indiana", IA:"Iowa", KS:"Kansas", KY:"Kentucky", LA:"Louisiana",
    ME:"Maine", MD:"Maryland", MA:"Massachusetts", MI:"Michigan", MN:"Minnesota",
    MS:"Mississippi", MO:"Missouri", MT:"Montana", NE:"Nebraska", NV:"Nevada",
    NH:"New Hampshire", NJ:"New Jersey", NM:"New Mexico", NY:"New York",
    NC:"North Carolina", ND:"North Dakota", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
    PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota",
    TN:"Tennessee", TX:"Texas", UT:"Utah", VT:"Vermont", VA:"Virginia", WA:"Washington",
    WV:"West Virginia", WI:"Wisconsin", WY:"Wyoming", DC:"District of Columbia",
    PR:"Puerto Rico", GU:"Guam", VI:"Virgin Islands", AS:"American Samoa", MP:"Northern Mariana Islands"
  };
  const STATE_FULL_TO_ABBR = Object.fromEntries(Object.entries(STATE_ABBR_TO_FULL).map(([k,v])=>[v.toLowerCase(), k]));
  function normalizeStateToken(token){
    if(!token) return {abbr:"", full:""};
    const t = token.trim();
    if (STATE_ABBR_TO_FULL[t.toUpperCase()]) return { abbr:t.toUpperCase(), full: STATE_ABBR_TO_FULL[t.toUpperCase()] };
    const ab = STATE_FULL_TO_ABBR[t.toLowerCase()];
    if (ab) return { abbr:ab, full:STATE_ABBR_TO_FULL[ab] };
    return { abbr:"", full:"" };
  }
  function findStateInText(text){
    if (!text) return null;
    const t = text.toLowerCase();
    let best = null;
    for (const [fullLower, abbr] of Object.entries(STATE_FULL_TO_ABBR)){
      const idx = t.indexOf(fullLower);
      if (idx !== -1){
        if (!best || fullLower.length > best.fullLower.length){
          best = { abbr, full: STATE_ABBR_TO_FULL[abbr], fullLower };
        }
      }
    }
    return best ? { abbr: best.abbr, full: best.full } : null;
  }
  const cleanCityToken = s => (s||"").replace(/^\s*(?:the\s+)?\d{3,4}\s+/i, "").trim();
  const displayLabel = d => (d.locCity && d.locStAbbr)?`${d.locCity}, ${d.locStAbbr}`:(d.locStAbbr||d.locLabel||d.region||"Location");

  /* ---------- Layout & map ---------- */
  const svg = d3.select("#svg");
  const zoomLayer = svg.append("g");
  const mapG = zoomLayer.append("g");
  const ptsG = zoomLayer.append("g");
  const legendG = svg.append("g");
  const tooltip = d3.select("#tooltip");

  function sizeSVG(){
    const r = document.querySelector(".view").getBoundingClientRect();
    const w = Math.max(100, r.width||0);
    const h = Math.max(100, r.height||0);
    svg.attr("viewBox", [0,0,w,h]);
    return { width:w, height:h };
  }
  let { width, height } = sizeSVG();
  window.addEventListener("resize", ()=>{ ({width,height}=sizeSVG()); updateProjection(); drawLegend(); render(); });

  let projection = d3.geoAlbersUsa();
  let path = d3.geoPath(projection);
  function updateProjection(){
    projection = d3.geoAlbersUsa().translate([width/2, height/2]).scale(Math.max(300, Math.min(width,height)*1.8));
    path = d3.geoPath(projection);
    mapG.selectAll("path").attr("d",path);
  }

  const us = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r=>r.json());
  const states = topojson.feature(us, us.objects.states);
  const borders = topojson.mesh(us, us.objects.states, (a,b)=>a!==b);
  mapG.append("path").datum(states).attr("class","states").attr("d", path);
  mapG.append("path").datum(borders).attr("class","state-borders").attr("d", path);

  /* ---------- Data ---------- */
  const data = await d3.csv("us_earthquakes_m4.5.csv", d=>{
    const depth = (d.depth===""||d.depth==null)?null:+d.depth;
    const mag   = (d.mag===""  ||d.mag==null)?null:+d.mag;
    const lat=+d.latitude, lon=+d.longitude;
    const year = d.time ? new Date(d.time).getUTCFullYear() : null;
    return { time:d.time, year, place:d.place||"", region:d.region||"", depth, mag, lat, lon };
  });
  const points = data.filter(d => isFinite(d.lat) && isFinite(d.lon));

  function cityStateFromPlace(d){
    const place = (d.place||"").trim();
    const region = (d.region||"").trim();

    let m = place.match(/of\s+([^,]+)\s*,\s*([A-Za-z.\s-]{2,})(?:\s+Earthquake)?\s*$/i);
    if (m){
      const city = cleanCityToken(m[1]); const st = normalizeStateToken(m[2]);
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    m = place.match(/^\s*([^,]+)\s*,\s*([A-Za-z.\s-]{2,})(?:\s+Earthquake)?\s*$/i);
    if (m){
      const city = cleanCityToken(m[1]); const st = normalizeStateToken(m[2]);
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    if (region){
      const parts = region.split(",").map(s=>s.trim());
      if (parts.length===2){
        const city = cleanCityToken(parts[0]); const st = normalizeStateToken(parts[1]);
        return { label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full };
      } else if (parts.length===1){
        const st = normalizeStateToken(parts[0]);
        if (st.abbr) return { label: st.abbr, city:"", stAbbr:st.abbr, stFull:st.full };
      }
    }
    const found = findStateInText(place) || findStateInText(region);
    if (found) return { label: found.abbr, city:"", stAbbr:found.abbr, stFull:found.full };

    const tail = place.split(',').map(s=>s.trim());
    if (tail.length>=2){
      const st = normalizeStateToken(tail[tail.length-1]);
      const city = cleanCityToken(tail[tail.length-2].replace(/.*of\s+/i,''));
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    return {label:"", city:"", stAbbr:"", stFull:""};
  }

  points.forEach(d => {
    const cs = cityStateFromPlace(d);
    d.locLabel = cs.label;
    d.locCity  = cs.city;
    d.locStAbbr= cs.stAbbr;
    d.locStFull= cs.stFull;
  });

  /* ---------- Location entries (canonical display) ---------- */
  const locMap = new Map();
  for (const d of points){
    if (!d.locLabel) continue;
    const key = d.locLabel;
    const rawPlace = (d.place||"").toLowerCase();
    const rawRegion= (d.region||"").toLowerCase();
    const labelLower = key.toLowerCase();
    const withFull = d.locCity ? `${d.locCity}, ${d.locStFull}` : d.locStFull;
    const withFullLower = (withFull||"").toLowerCase();

    if (!locMap.has(key)){
      locMap.set(key, { label:key, count:1, forms:new Set([labelLower, withFullLower, rawPlace, rawRegion]), stAbbr:d.locStAbbr||"", stFull:d.locStFull||"" });
    } else {
      const e = locMap.get(key);
      e.count++;
      e.forms.add(labelLower);
      if (withFullLower) e.forms.add(withFullLower);
      if (rawPlace) e.forms.add(rawPlace);
      if (rawRegion) e.forms.add(rawRegion);
    }
  }
  const locEntries = Array.from(locMap.values())
    .map(e => ({ label:e.label, count:e.count, forms:Array.from(e.forms), stAbbr:e.stAbbr, stFull:e.stFull }))
    .sort((a,b)=> d3.descending(a.count,b.count) || d3.ascending(a.label,b.label));

  /* ---------- Scales & UI state (safe domains) ---------- */
  const depthExt  = safeExtent(points.map(d=>d.depth).filter(v=>v!=null && isFinite(v)), [0,700]);
  const dDomMin   = clamp(Math.floor(depthExt[0]), 0, 10000);
  const dDomMax   = clamp(Math.ceil(depthExt[1]), dDomMin+1, 10000);

  const magExt    = safeExtent(points.map(d=>d.mag).filter(v=>v!=null && isFinite(v)), [4.5,9.5]);
  const yearExt   = safeExtent(points.map(d=>d.year).filter(v=>v!=null && isFinite(v)), [1900, 2025]);

  const color = d3.scaleSequential([dDomMin, dDomMax], d3.interpolateTurbo);
  const sizeScale = d3.scaleSqrt().domain(magExt).range([1.8, 11]);

  let magRange=[magExt[0],magExt[1]], depthRange=[dDomMin,dDomMax], yearRange=[yearExt[0],yearExt[1]];
  const selectedLocs = new Set(); // "City, ST" or "ST"

  /* ---------- Dual sliders init (safe) ---------- */
  function initDual({domain,step,ids,onChange,labelElId}){
    const [loR,hiR,loN,hiN]=[ids.lowerRange,ids.upperRange,ids.lowerNum,ids.upperNum].map(id=>document.getElementById(id));
    const label=document.getElementById(labelElId);
    [loR.min,hiR.min,loN.min,hiN.min]=[domain[0],domain[0],domain[0],domain[0]];
    [loR.max,hiR.max,loN.max,hiN.max]=[domain[1],domain[1],domain[1],domain[1]];
    [loR.step,hiR.step,loN.step,hiN.step]=[step,step,step,step];
    const round=(v)=> step>=1?Math.round(v/step)*step:Math.round(v*10)/10;
    const clampD=v=>clamp(round(v), domain[0], domain[1]);
    const paint=(a,b)=>{const p=v=>100*(v-domain[0])/(domain[1]-domain[0]||1);loR.style.background=`linear-gradient(to right,#dfe8f6 ${p(domain[0])}%,var(--accent) ${p(a)}%,var(--accent) ${p(b)}%,#dfe8f6 ${p(domain[1])}%)`;};
    const sync=(a,b,notify=true)=>{a=clampD(a);b=clampD(b);if(a>b)[a,b]=[b,a];[loR.value,hiR.value,loN.value,hiN.value]=[a,b,a,b];paint(a,b);if(label){const f=step===0.1?x=>(+x).toFixed(1):x=>x;label.textContent=`${f(a)} ‚Äì ${f(b)}`;}if(notify)onChange([a,b]);};
    loR.oninput=()=>sync(+loR.value,+hiR.value);
    hiR.oninput=()=>sync(+loR.value,+hiR.value);
    loN.onchange=()=>sync(+loN.value,+hiN.value);
    hiN.onchange=()=>sync(+loN.value,+hiN.value);
    sync(domain[0],domain[1],false); onChange([domain[0],domain[1]]);
  }
  initDual({ domain:magExt, step:0.1, ids:{lowerRange:'magMinR',upperRange:'magMaxR',lowerNum:'magMinN',upperNum:'magMaxN'}, labelElId:'magVals', onChange:r=>{ magRange=r; render(); }});
  initDual({ domain:[dDomMin,dDomMax], step:10, ids:{lowerRange:'depthMinR',upperRange:'depthMaxR',lowerNum:'depthMinN',upperNum:'depthMaxN'}, labelElId:'depthVals', onChange:r=>{ depthRange=r; render(); }});
  initDual({ domain:yearExt, step:1, ids:{lowerRange:'yearMinR',upperRange:'yearMaxR',lowerNum:'yearMinN',upperNum:'yearMaxN'}, labelElId:'yearVals', onChange:r=>{ yearRange=r; render(); }});

  /* ---------- Location: suggestions + chips ---------- */
  const locInput = document.getElementById("locInput");
  const locPanel = document.getElementById("locSuggest");
  const chipsBox = document.getElementById("chips");
  const clearBtn = document.getElementById("clearLoc");
  let activeIdx = -1;

  const canonQuery = (q)=>{
    const parts = q.split(",").map(s=>s.trim());
    if (parts.length>=2){
      const stateTok = parts.pop();
      const ab = STATE_ABBR_TO_FULL[stateTok.toUpperCase()] ? stateTok.toUpperCase()
               : (STATE_FULL_TO_ABBR[stateTok.toLowerCase()] || "");
      return parts.join(", ") + (ab ? (", " + ab) : "");
    }
    return q;
  };

  function closePanel(){ locPanel.style.display = "none"; activeIdx=-1; }
  function openPanel(){ if (locPanel.childElementCount>0){ locPanel.style.display = "block"; } }

  function renderChips(){
    chipsBox.innerHTML = "";
    for (const label of selectedLocs){
      const span = document.createElement("span");
      span.className = "chip";
      span.innerHTML = `${label} <span class="x" title="Remove">√ó</span>`;
      span.querySelector(".x").onclick = ()=>{ selectedLocs.delete(label); renderChips(); render(); };
      chipsBox.appendChild(span);
    }
  }
  function addSelection(label){
    if (!label) return;
    selectedLocs.add(label);
    renderChips(); render();
  }

  function renderSuggestions(qRaw){
    const qTrim = (qRaw||"").trim();
    const qLower = qTrim.toLowerCase();
    locPanel.innerHTML = "";
    if (!qTrim){ closePanel(); return; }

    const abbrOnly = STATE_ABBR_TO_FULL[qTrim.toUpperCase()] ? qTrim.toUpperCase() : "";
    const fullOnlyAbbr = STATE_FULL_TO_ABBR[qLower] || "";

    let results = [];

    if (abbrOnly || fullOnlyAbbr){
      const ab = abbrOnly || fullOnlyAbbr;
      const stateTop = { label: ab, count: 0, _state:true };
      const cityList = locEntries.filter(e => e.stAbbr === ab);
      results = [stateTop, ...cityList];
    } else {
      const qCanon = canonQuery(qTrim).toLowerCase();
      const starts = [], contains = [];
      for (const e of locEntries){
        const mStart = e.forms.some(f => f && (f.startsWith(qCanon) || f.startsWith(qLower)));
        const mCont  = !mStart && e.forms.some(f => f && f.includes(qLower));
        if (mStart) starts.push(e); else if (mCont) contains.push(e);
        if (starts.length >= 10) break;
      }
      results = starts.concat(contains);
    }

    if (!results.length){ closePanel(); return; }

    for (const r of results){
      const div = document.createElement("div");
      div.className = "loc-item";
      if (r._state){
        div.textContent = r.label + " (all)"; const sm=document.createElement("small"); sm.textContent="state"; div.appendChild(sm);
      } else {
        div.textContent = r.label; const sm=document.createElement("small"); sm.textContent=r.count; div.appendChild(sm);
      }
      div.addEventListener("mousedown", (e)=>{ e.preventDefault(); addSelection(r.label); locInput.value = "";});
      locPanel.appendChild(div);
    }
    activeIdx = -1; openPanel();
  }
  function applyTyped(){
    const typed = locInput.value.trim();
    if (!typed) return;
    const ab = STATE_ABBR_TO_FULL[typed.toUpperCase()] ? typed.toUpperCase()
             : (STATE_FULL_TO_ABBR[typed.toLowerCase()] || "");
    if (ab){ addSelection(ab); return; }
    const typedCanon = canonQuery(typed);
    if (locMap.has(typedCanon)) { addSelection(typedCanon); return; }
    if (locMap.has(typed))      { addSelection(typed); return; }
  }
  locInput.addEventListener("input", (e)=> renderSuggestions(e.target.value));
  locInput.addEventListener("keydown", (e)=>{
    const items = Array.from(locPanel.children);
    if (e.key === "ArrowDown" && items.length){
      e.preventDefault(); activeIdx = Math.min(items.length-1, activeIdx+1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
      if (activeIdx>=0) items[activeIdx].scrollIntoView({block:"nearest"});
    } else if (e.key === "ArrowUp" && items.length){
      e.preventDefault(); activeIdx = Math.max(-1, activeIdx-1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
    } else if (e.key === "Enter"){
      e.preventDefault();
      if (activeIdx>=0 && items[activeIdx]){
        const txt = items[activeIdx].textContent.replace(/\s+\(all\)\s*state?$/,'').trim();
        addSelection(txt);
      } else {
        applyTyped();
      }
      locInput.value = ""; closePanel();
    } else if (e.key === "Backspace" && !locInput.value){
      const last = Array.from(selectedLocs).pop(); if (last){ selectedLocs.delete(last); renderChips(); render(); }
    } else if (e.key === "Escape"){ closePanel(); }
  });
  document.addEventListener("click", (e)=>{ if (!document.querySelector(".locbox").contains(e.target)) closePanel(); });
  document.getElementById("clearLoc").onclick = ()=>{ selectedLocs.clear(); renderChips(); render(); };

  /* ---------- Legend ---------- */
  function drawLegend(){
    legendG.selectAll("*").remove();
    const pad = 10;
    const cardW = Math.min(260, Math.max(220, width * 0.22));
    const depthBarH = 12;

    const mags = safeExtent(points.map(d=>d.mag).filter(v=>v!=null && isFinite(v)), [4.5,9.5]);
    const sScale = d3.scaleSqrt().domain(mags).range([3, 9]);
    const maxR = sScale(mags[1]);

    const cardH = 26 + depthBarH + 12 + 16 + 8 + 26 + maxR + 12 + 8;
    const x0 = width - cardW - 12;
    const y0 = height - cardH - 12;

    legendG.append("rect").attr("class","legend-card").attr("x",x0).attr("y",y0).attr("width",cardW).attr("height",cardH);
    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",y0+18).text("Depth (km)");

    const barW = cardW - pad*2;
    const gradId = "depthGrad";
    const defs = legendG.append("defs");
    const grad = defs.append("linearGradient").attr("id",gradId).attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");
    const [d0,d1] = color.domain();
    for (let i=0;i<=12;i++){ const t=i/12, val=d0+t*(d1-d0); grad.append("stop").attr("offset",`${t*100}%`).attr("stop-color", color(val)); }
    legendG.append("rect").attr("x",x0+pad).attr("y",y0+26).attr("width",barW).attr("height",depthBarH).attr("rx",6).attr("ry",6).attr("fill",`url(#${gradId})`).attr("stroke","#243142");

    const tickY = y0 + 26 + depthBarH + 12;
    [d0, Math.round((d0+d1)/2), d1].forEach((t,i)=>{
      const tx = x0 + pad + (barW * i/2);
      legendG.append("text").attr("x",tx).attr("y",tickY).attr("text-anchor", i===0?'start':i===2?'end':'middle').attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6').attr("font-size",11).text(t);
    });

    const magVals = [mags[0], (mags[0]+mags[1])/2, mags[1]].map(v=>+v.toFixed(1));
    const cxLeft  = x0 + pad + maxR + 4;
    const cxRight = x0 + cardW - pad - maxR - 4;
    const gap = (cxRight - cxLeft) / (magVals.length - 1);
    const circlesY = tickY + 8 + 16 + 10 + 16;

    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",tickY+8+16).text("Magnitude");

    magVals.forEach((m,i)=>{
      const cx = cxLeft + i*gap, r = sScale(m);
      legendG.append("circle").attr("cx",cx).attr("cy",circlesY).attr("r",r).attr("fill","#e6e6e6").attr("fill-opacity",.9).attr("stroke","#000").attr("stroke-opacity",.4);
      legendG.append("text").attr("x",cx).attr("y",circlesY + r + 12).attr("text-anchor","middle").attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6').attr("font-size",11).text(m);
    });
  }

  /* ---------- Render ---------- */
  function render(){
    try{
      const allowNA = document.getElementById("includeNA").checked;

      const filtered = points.filter(d=>{
        const magOK   = (d.mag  != null && d.mag  >= magRange[0]   && d.mag  <= magRange[1]);
        const yearOK  = (d.year != null && d.year >= yearRange[0]  && d.year <= yearRange[1]);
        const depthOK = d.depth == null ? allowNA : (d.depth >= depthRange[0] && d.depth <= depthRange[1]);

        let locOK = true;
        if (selectedLocs.size > 0){
          const st  = (d.locStAbbr||"").toUpperCase();
          const lbl = (d.locLabel||"");
          locOK = (st && selectedLocs.has(st)) || (lbl && selectedLocs.has(lbl));
        }
        return magOK && yearOK && depthOK && locOK;
      });

      // Keep the base map visible regardless; only points are filtered
      const sel = ptsG.selectAll("circle.quake").data(filtered, (d,i)=> (d.time||"t")+ "|" + i);

      sel.enter().append("circle")
        .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
        .attr("r", d => sizeScale(d.mag ?? magExt[0]))
        .attr("transform", d => {
          const p = projection([d.lon, d.lat]); return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
        })
        .attr("fill", d => d.depth==null ? "#9aa0a6" : color(clamp(d.depth, dDomMin, dDomMax)))
        .attr("fill-opacity", .85)
        .on("mousemove", (event, d) => {
          const [x,y] = d3.pointer(event, document.querySelector(".view"));
          tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(`
            <div><b>${(d.mag!=null?d.mag.toFixed(1):"M?")}</b> ‚Äî <span style="color:var(--muted)">${displayLabel(d)}</span></div>
            <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
            <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
          `);
        })
        .on("mouseleave", ()=> tooltip.style("opacity", 0));

      sel
        .attr("r", d => sizeScale(d.mag ?? magExt[0]))
        .attr("fill", d => d.depth==null ? "#9aa0a6" : color(clamp(d.depth, dDomMin, dDomMax)))
        .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
        .attr("transform", d => {
          const p = projection([d.lon, d.lat]); return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
        });

      sel.exit().remove();
    }catch(err){
      console.error("Render error:", err); // keeps page alive
    }
  }

  updateProjection();
  drawLegend();
  render();


  // ----- Reset Filters Button Logic -----
  document.getElementById("resetBtn").addEventListener("click", () => {
    function resetDual(minRangeId, maxRangeId, minNumId, maxNumId, minVal, maxVal) {
      const loR = document.getElementById(minRangeId);
      const hiR = document.getElementById(maxRangeId);
      const loN = document.getElementById(minNumId);
      const hiN = document.getElementById(maxNumId);
      loR.value = minVal; hiR.value = maxVal;
      loN.value = minVal; hiN.value = maxVal;
      hiR.dispatchEvent(new Event('input', { bubbles: true }));
    }

    resetDual('magMinR', 'magMaxR', 'magMinN', 'magMaxN',
              sizeScale.domain()[0], sizeScale.domain()[1]);

    resetDual('depthMinR', 'depthMaxR', 'depthMinN', 'depthMaxN',
              color.domain()[0], color.domain()[1]);

    resetDual('yearMinR', 'yearMaxR', 'yearMinN', 'yearMaxN',
              yearExt[0], yearExt[1]);

    d3.select("#includeNA").property("checked", false);

    d3.select("#locInput").property("value", "");
    if (typeof selectedLocs !== "undefined") {
      selectedLocs.clear();
      if (typeof renderChips === "function") renderChips();
    }

    render();
  });


  /* ---------- Zoom ---------- */
  const zoom = d3.zoom().scaleExtent([0.9, 8]).on("zoom", (ev)=> zoomLayer.attr("transform", ev.transform));
  svg.call(zoom).on("click", (e)=>{
    if (e.target === svg.node()) svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
  });

  document.getElementById("includeNA").addEventListener("change", render);
})();
</script>
</body>
</html>
