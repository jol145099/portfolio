<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D3 US Earthquakes — Native Dual Sliders</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
<style>
  :root { --bg:#0b0e14; --text:#e8eef7; --muted:#9fb0c6; --grid:#243142; --accent:#1f62d6; }
  *{ box-sizing:border-box }
  body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; height:100vh; overflow:hidden }
  header{ height:48px; display:flex; align-items:center; gap:10px; padding:0 12px; border-bottom:1px solid var(--grid); white-space:nowrap; overflow:hidden }
  header h1{ font-size:16px; margin:0; font-weight:600 }
  header .sub{ color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis }

  .topbar{
    position:absolute; top:52px; left:8px; right:8px;
    display:grid; grid-template-columns:1fr; gap:8px;
    background:rgba(15,20,28,.9); border:1px solid var(--grid); border-radius:10px;
    padding:8px 10px; z-index:2; backdrop-filter:blur(2px);
  }
  .filters{ display:grid; grid-template-columns:1fr; gap:8px }
  .row{ display:grid; grid-template-columns:110px 1fr auto; gap:8px; align-items:center }
  .label{ color:var(--muted); font-size:12px }
  .values{ color:var(--muted); font-size:12px; white-space:nowrap; font-variant-numeric:tabular-nums }
  .opts{ display:flex; gap:16px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:12px }

  .view{ position:absolute; inset:170px 0 0 0 }
  svg{ width:100%; height:100%; display:block }

  .states{ fill:#0d1320; stroke:#2a3a52; stroke-width:.6 }
  .state-borders{ fill:none; stroke:#2a3a52; stroke-width:.6; pointer-events:none }
  .quake{ stroke:#000; stroke-opacity:.45 }
  .nodata{ fill:#9aa0a6 !important; opacity:.9 }

  .legend-card{ fill:rgba(10,14,20,.9); stroke:var(--grid); stroke-width:1; filter:drop-shadow(0 8px 16px rgba(0,0,0,.35)); rx:10; ry:10 }
  .legend-title{ fill:#9ad1ff; font-weight:600; font-size:12px }
  .tooltip{ position:absolute; pointer-events:none; opacity:0; background:#0d1320; color:var(--text); border:1px solid var(--grid); padding:8px 10px; font-size:12px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); transform:translate(-50%,-120%) }

  /* Native dual-handle slider (stacked inputs) */
  .slider2{ position:relative; height:38px; display:flex; align-items:center }
  .slider2 input[type="range"]{
    -webkit-appearance:none; appearance:none;
    position:absolute; width:100%; background:none; pointer-events:none;
  }
  .slider2 input[type="range"]::-webkit-slider-runnable-track{
    height:8px; border-radius:999px; background:#dfe8f6;  /* base track */
  }
  .slider2 input[type="range"]::-moz-range-track{
    height:8px; border-radius:999px; background:#dfe8f6;
  }
  .slider2 input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none;
    width:16px; height:16px; border-radius:50%;
    background:#ffffff; border:2px solid var(--accent);
    margin-top:-4px; pointer-events:auto;
  }
  .slider2 input[type="range"]::-moz-range-thumb{
    width:16px; height:16px; border-radius:50%;
    background:#ffffff; border:2px solid var(--accent); pointer-events:auto;
  }
  .slider2 input.lower{ z-index:1 } /* lower track gets the blue fill gradient */
  .slider2 input.upper{ z-index:2 }

  input[type="number"]{ background:#0f141c; color:var(--text); border:1px solid var(--grid); border-radius:6px; padding:4px 6px }
  .disabled{ opacity:.55 }
</style>
</head>
<body>
<header>
  <h1>US Earthquakes — Native Dual Sliders</h1>
  <div class="sub">Size = magnitude, color = depth (km). Pan/zoom; filter with dual sliders for magnitude, depth, and year.</div>
</header>

<div class="topbar">
  <div class="filters">
    <!-- Magnitude -->
    <div class="row">
      <div class="label">Magnitude</div>
      <div class="slider2" id="magSlider">
        <input id="magMinR" class="lower" type="range" step="0.1">
        <input id="magMaxR" class="upper" type="range" step="0.1">
      </div>
      <div class="values"><span id="magVals">—</span></div>
    </div>
    <div class="row" style="grid-template-columns:110px 1fr auto;">
      <div class="label"></div>
      <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
        <span>Min</span><input id="magMinN" type="number" step="0.1" style="width:80px;">
        <span>Max</span><input id="magMaxN" type="number" step="0.1" style="width:80px;">
      </div>
      <div></div>
    </div>

    <!-- Depth -->
    <div class="row">
      <div class="label">Depth (km)</div>
      <div class="slider2" id="depthSlider">
        <input id="depthMinR" class="lower" type="range" step="10">
        <input id="depthMaxR" class="upper" type="range" step="10">
      </div>
      <div class="values"><span id="depthVals">—</span></div>
    </div>
    <div class="row" style="grid-template-columns:110px 1fr auto;">
      <div class="label"></div>
      <div class="opts">
        <label><input id="autoDepthMax" type="checkbox" checked> Auto max depth</label>
        <label><input id="includeNA" type="checkbox" checked> Include N/A depth</label>
        <span>Min</span><input id="depthMinN" type="number" step="10" style="width:80px;">
        <span>Max</span><input id="depthMaxN" type="number" step="10" style="width:80px;">
      </div>
      <div></div>
    </div>

    <!-- Year -->
    <div class="row">
      <div class="label">Year</div>
      <div class="slider2" id="yearSlider">
        <input id="yearMinR" class="lower" type="range" step="1">
        <input id="yearMaxR" class="upper" type="range" step="1">
      </div>
      <div class="values"><span id="yearVals">—</span></div>
    </div>
    <div class="row" style="grid-template-columns:110px 1fr auto;">
      <div class="label"></div>
      <div style="display:flex; gap:14px; align-items:center; flex-wrap:wrap;">
        <span>Min</span><input id="yearMinN" type="number" step="1" style="width:80px;">
        <span>Max</span><input id="yearMaxN" type="number" step="1" style="width:80px;">
      </div>
      <div></div>
    </div>
  </div>
  <div style="text-align:right; color:var(--muted); font-size:11px">Click empty map to reset zoom</div>
</div>

<div class="view">
  <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
  <div class="tooltip" id="tooltip"></div>
</div>

<script>
(async function () {
  const svg = d3.select("#svg");
  const zoomLayer = svg.append("g");
  const mapG = zoomLayer.append("g");
  const ptsG = zoomLayer.append("g");
  const legendG = svg.append("g");
  const tooltip = d3.select("#tooltip");

  function sizeSVG(){
    const r = document.querySelector(".view").getBoundingClientRect();
    svg.attr("viewBox", [0,0,r.width,r.height]);
    return { width:r.width, height:r.height };
  }
  let { width, height } = sizeSVG();
  window.addEventListener("resize", ()=>{ ({width,height}=sizeSVG()); drawLegend(); render(); });

  // Projection & map
  const projection = d3.geoAlbersUsa().translate([width/2, height/2]).scale(Math.min(width,height)*1.2);
  const path = d3.geoPath(projection);
  const us = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r=>r.json());
  const states = topojson.feature(us, us.objects.states);
  const borders = topojson.mesh(us, us.objects.states, (a,b)=>a!==b);
  mapG.append("path").datum(states).attr("class","states").attr("d", path);
  mapG.append("path").datum(borders).attr("class","state-borders").attr("d", path);

  // Data
  const data = await d3.csv("us_earthquakes_m4.5.csv", d=>{
    const depth = (d.depth===""||d.depth==null)?null:+d.depth;
    const mag   = (d.mag===""  ||d.mag==null)  ?null:+d.mag;
    const lat=+d.latitude, lon=+d.longitude;
    const year = d.time ? new Date(d.time).getUTCFullYear() : null;
    return { time:d.time, year, place:d.place||"", region:d.region||"", depth, mag, lat, lon };
  });
  const points = data.filter(d => isFinite(d.lat) && isFinite(d.lon));

  // Domains
  const depthVals = points.map(d=>d.depth).filter(v=>v!=null && isFinite(v));
  const depthExt  = d3.extent(depthVals.length ? depthVals : [0,700]);
  const dDomMin   = Math.max(0, Math.floor((depthExt[0] ?? 0)));
  const dDomMax   = Math.min(700, Math.ceil((depthExt[1] ?? 700)));

  const magVals = points.map(d=>d.mag).filter(v=>v!=null && isFinite(v));
  const magDom  = d3.extent(magVals.length ? magVals : [4.5,8]);

  const yearVals = points.map(d=>d.year).filter(y=>y!=null && isFinite(y));
  const yearDom  = d3.extent(yearVals.length ? yearVals : [1950, 2025]);

  const color = d3.scaleSequential([dDomMin, dDomMax], d3.interpolateTurbo);
  const size  = d3.scaleSqrt().domain(magDom).range([1.8, 11]);

  // UI state
  let magRange   = [magDom[0], magDom[1]];
  let depthRange = [dDomMin, dDomMax];
  let yearRange  = [yearDom[0], yearDom[1]];

  // Generic native dual-slider initializer
  function initDualNative({
    domain, step, initial, ids, onChange, lockMaxCheckboxId=null, labelElId
  }){
    const lowerR = document.getElementById(ids.lowerRange);
    const upperR = document.getElementById(ids.upperRange);
    const lowerN = document.getElementById(ids.lowerNum);
    const upperN = document.getElementById(ids.upperNum);
    const label  = document.getElementById(labelElId);
    const lockBox = lockMaxCheckboxId ? document.getElementById(lockMaxCheckboxId) : null;

    // configure min/max/step
    [lowerR.min, upperR.min, lowerN.min, upperN.min] = [domain[0], domain[0], domain[0], domain[0]];
    [lowerR.max, upperR.max, lowerN.max, upperN.max] = [domain[1], domain[1], domain[1], domain[1]];
    [lowerR.step, upperR.step, lowerN.step, upperN.step] = [step, step, step, step];

    const clamp = v => Math.min(domain[1], Math.max(domain[0], (step>=1? Math.round(v/step)*step : Math.round(v*10)/10)));

    function paintTrack(minV, maxV){
      const pct = v => 100 * (v - domain[0]) / (domain[1] - domain[0]);
      const g = `linear-gradient(to right,
        #dfe8f6 ${pct(domain[0])}%,
        var(--accent) ${pct(minV)}%,
        var(--accent) ${pct(maxV)}%,
        #dfe8f6 ${pct(domain[1])}%)`;
      lowerR.style.background = g;
    }

    function sync([lo, hi], notify=true){
      let minV = clamp(Math.min(lo, hi));
      let maxV = clamp(Math.max(lo, hi));
      if (lockBox && lockBox.checked) maxV = domain[1];

      lowerR.value = minV; upperR.value = maxV;
      lowerN.value = minV; upperN.value = maxV;
      paintTrack(minV, maxV);

      if (label){
        const fmt = step===0.1 ? (x=>(+x).toFixed(1)) : (x=>x);
        label.textContent = `${fmt(minV)} – ${fmt(maxV)}${lockBox && lockBox.checked ? ' (auto max)' : ''}`;
      }

      if (lockBox){
        if (lockBox.checked){
          upperR.setAttribute('disabled', 'disabled');
          upperN.setAttribute('disabled', 'disabled');
          upperR.classList.add('disabled'); upperN.classList.add('disabled');
        } else {
          upperR.removeAttribute('disabled'); upperN.removeAttribute('disabled');
          upperR.classList.remove('disabled'); upperN.classList.remove('disabled');
        }
      }

      if (notify) onChange([minV, maxV]);
    }

    // Events
    lowerR.addEventListener('input', ()=> {
      const lo = +lowerR.value, hi = +upperR.value;
      if (lo > hi && !(lockBox && lockBox.checked)) upperR.value = lo;
      sync([+lowerR.value, +upperR.value]);
    });
    upperR.addEventListener('input', ()=> {
      if (lockBox && lockBox.checked) return;
      const lo = +lowerR.value, hi = +upperR.value;
      if (hi < lo) lowerR.value = hi;
      sync([+lowerR.value, +upperR.value]);
    });

    lowerN.addEventListener('change', ()=> {
      const lo = clamp(+lowerN.value);
      const hi = (lockBox && lockBox.checked) ? domain[1] : clamp(+upperN.value);
      sync([lo, hi]);
    });
    upperN.addEventListener('change', ()=> {
      if (lockBox && lockBox.checked) return;
      const lo = clamp(+lowerN.value), hi = clamp(+upperN.value);
      sync([lo, hi]);
    });

    if (lockBox){
      lockBox.addEventListener('change', ()=> {
        const lo = clamp(+lowerN.value);
        const hi = lockBox.checked ? domain[1] : clamp(+upperN.value);
        sync([lo, hi]);
      });
    }

    // Initial paint
    sync(initial ?? domain, /*notify=*/true);
    // Return a way to programmatically update (e.g., on window resize if needed)
    return { set: (rng)=> sync(rng, true) };
  }

  // Initialize Magnitude slider
  const magCtrl = initDualNative({
    domain: magDom, step: 0.1, initial: magRange,
    ids: { lowerRange:'magMinR', upperRange:'magMaxR', lowerNum:'magMinN', upperNum:'magMaxN' },
    labelElId: 'magVals',
    onChange: (r)=>{ magRange = r; render(); }
  });

  // Initialize Depth slider (with Auto max lock)
  const depthCtrl = initDualNative({
    domain: [dDomMin, dDomMax], step: 10, initial: depthRange,
    ids: { lowerRange:'depthMinR', upperRange:'depthMaxR', lowerNum:'depthMinN', upperNum:'depthMaxN' },
    lockMaxCheckboxId: 'autoDepthMax',
    labelElId: 'depthVals',
    onChange: (r)=>{ depthRange = r; render(); }
  });

  // Initialize Year slider
  const yearCtrl = initDualNative({
    domain: yearDom, step: 1, initial: yearRange,
    ids: { lowerRange:'yearMinR', upperRange:'yearMaxR', lowerNum:'yearMinN', upperNum:'yearMaxN' },
    labelElId: 'yearVals',
    onChange: (r)=>{ yearRange = r; render(); }
  });

  // Legend (fixed)
  function drawLegend(){
    legendG.selectAll("*").remove();
    const pad=10, cardW=Math.min(260,Math.max(220,width*0.22)), cardH=110;
    const x0=width-cardW-12, y0=height-cardH-12;

    legendG.append("rect").attr("class","legend-card").attr("x",x0).attr("y",y0).attr("width",cardW).attr("height",cardH);

    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",y0+18).text("Depth (km)");

    const barW=cardW-pad*2, barH=12, gradId="depthGrad";
    const defs=legendG.append("defs");
    const grad=defs.append("linearGradient").attr("id",gradId).attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");
    const stops=12;
    for(let i=0;i<=stops;i++){
      const t=i/stops, val=dDomMin + t*(dDomMax-dDomMin);
      grad.append("stop").attr("offset",`${t*100}%`).attr("stop-color", color(val));
    }
    legendG.append("rect").attr("x",x0+pad).attr("y",y0+26).attr("width",barW).attr("height",barH)
      .attr("rx",6).attr("ry",6).attr("fill",`url(#${gradId})`).attr("stroke","#243142");
    const tickY=y0+26+barH+12;
    [dDomMin, Math.round((dDomMin+dDomMax)/2), dDomMax].forEach((t,i)=>{
      const tx = x0+pad + (barW * i/2);
      legendG.append("text").attr("x",tx).attr("y",tickY)
        .attr("text-anchor", i===0?'start':i===2?'end':'middle')
        .attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6')
        .attr("font-size",11).text(t);
    });

    const mags=[magDom[0], (magDom[0]+magDom[1])/2, magDom[1]].map(v=>+v.toFixed(1));
    const baseY=tickY+8;
    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",baseY+16).text("Magnitude");
    const cx0=x0+pad+72, gap=(cardW-pad-cx0-10)/(mags.length-1);
    mags.forEach((m,i)=>{
      const cx=cx0+i*gap, r=size(m);
      legendG.append("circle").attr("cx",cx).attr("cy",baseY+26).attr("r",r).attr("fill","#e6e6e6").attr("fill-opacity",.9)
        .attr("stroke","#000").attr("stroke-opacity",.4);
      legendG.append("text").attr("x",cx).attr("y",baseY+26+r+12).attr("text-anchor","middle")
        .attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6')
        .attr("font-size",11).text(m);
    });
  }

  function render(){
    const allowNA = document.getElementById("includeNA").checked;

    // Enforce auto max depth at render-time too (in case someone toggled it)
    const autoDepthMax = document.getElementById("autoDepthMax");
    if (autoDepthMax.checked) depthRange[1] = dDomMax;

    const filtered = points.filter(d=>{
      const magOK   = (d.mag  != null && d.mag  >= magRange[0]   && d.mag  <= magRange[1]);
      const yearOK  = (d.year != null && d.year >= yearRange[0]  && d.year <= yearRange[1]);
      const depthOK = d.depth == null ? allowNA : (d.depth >= depthRange[0] && d.depth <= depthRange[1]);
      return magOK && yearOK && depthOK;
    });

    const sel = ptsG.selectAll("circle.quake").data(filtered, (d,i)=>d.time+"|"+i);

    sel.enter().append("circle")
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      })
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("fill-opacity", .85)
      .on("mousemove", (event, d) => {
        const [x,y] = d3.pointer(event, document.querySelector(".view"));
        tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(`
          <div><b>${d.mag?.toFixed(1) ?? "M?"}</b> — <span style="color:var(--muted)">${d.place || d.region || "Location"}</span></div>
          <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
          <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
        `);
      })
      .on("mouseleave", ()=> tooltip.style("opacity", 0));

    sel
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      });

    sel.exit().remove();
  }

  drawLegend();
  render();

  // Zoom (legend fixed)
  const zoom = d3.zoom().scaleExtent([0.9, 8]).on("zoom", (ev)=> {
    zoomLayer.attr("transform", ev.transform);
  });
  svg.call(zoom).on("click", (e)=>{
    if (e.target === svg.node()) svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
  });
})();
</script>
</body>
</html>
