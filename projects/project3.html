<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>D3 US Earthquakes — Location Search (AZ / Arizona fixed)</title>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
<style>
  :root { --bg:#0b0e14; --text:#e8eef7; --muted:#9fb0c6; --grid:#243142; --accent:#1f62d6; --panel:#0f141c; }

  *{ box-sizing:border-box }
  body{ margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; height:100vh; overflow:hidden }

  header{ height:52px; display:flex; align-items:center; gap:10px; padding:0 12px; border-bottom:1px solid var(--grid); white-space:nowrap; overflow:hidden }
  header h1{ font-size:16px; margin:0; font-weight:600 }
  header .sub{ color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis }

  .layout{ position:absolute; inset:52px 0 0 0; display:grid; grid-template-columns: 340px 1fr; }
  @media (max-width:900px){ .layout{ grid-template-columns: 280px 1fr; } }

  .sidebar{ border-right:1px solid var(--grid); background:rgba(15,20,28,.94); padding:16px 14px; overflow-y:auto; overflow-x:hidden; }
  .filters{ display:grid; gap:16px }
  .section{ display:grid; gap:8px; padding-bottom:10px; border-bottom:1px dashed #1c2837 }
  .section:last-child{ border-bottom:none; }

  .row{ display:grid; grid-template-columns:90px 1fr; gap:8px; align-items:center }
  .label{ color:var(--muted); font-size:12px }
  .valuespan{ color:var(--muted); font-size:12px; font-variant-numeric:tabular-nums }

  .slider2{ position:relative; height:26px; display:flex; align-items:center; grid-column: 1 / span 2 }
  .slider2 input[type="range"]{ -webkit-appearance:none; appearance:none; position:absolute; width:100%; background:none; pointer-events:none; }
  .slider2 input[type="range"]::-webkit-slider-runnable-track{ height:5px; border-radius:999px; background:#dfe8f6; }
  .slider2 input[type="range"]::-moz-range-track{ height:5px; border-radius:999px; background:#dfe8f6; }
  .slider2 input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:12px; height:12px; border-radius:50%; background:#ffffff; border:2px solid var(--accent); margin-top:-4px; pointer-events:auto; }
  .slider2 input[type="range"]::-moz-range-thumb{ width:12px; height:12px; border-radius:50%; background:#ffffff; border:2px solid var(--accent); pointer-events:auto; }
  .slider2 input.lower{ z-index:1 } .slider2 input.upper{ z-index:2 }

  .row.values{ grid-template-columns: 1fr; }
  .row.values .label{ display:none; }
  .valuebox{ display:grid; grid-template-columns: auto 70px 20px auto 70px; align-items:center; gap:6px; color:var(--muted); font-size:11.5px; }
  input[type="number"]{ background:#0f141c; color:var(--text); border:1px solid var(--grid); border-radius:6px; padding:3px 6px; width:70px; }

  .checkboxrow label{ display:flex; align-items:center; gap:6px; color:var(--muted); font-size:11.5px; margin-top:4px; }

  /* Location autocomplete */
  .locbox{ position:relative; display:grid; gap:8px; }
  .locbox input[type="text"]{ width:100%; padding:6px 8px; border-radius:6px; border:1px solid var(--grid); background:#0f141c; color:var(--text); min-width:0; }
  .helper{ color:var(--muted); font-size:11px }

  .loc-suggest{ position:absolute; left:0; right:0; top: calc(100% + 4px); background:var(--panel); border:1px solid var(--grid); border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); max-height:220px; overflow-y:auto; z-index:20; display:none; }
  .loc-item{ padding:6px 8px; font-size:12px; color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; }
  .loc-item:hover, .loc-item.active{ background:#162031; }

  .view{ position:relative }
  svg{ width:100%; height:100%; display:block }

  .states{ fill:#0d1320; stroke:#2a3a52; stroke-width:.6 }
  .state-borders{ fill:none; stroke:#2a3a52; stroke-width:.6; pointer-events:none }
  .quake{ stroke:#000; stroke-opacity:.45 }
  .nodata{ fill:#9aa0a6 !important; opacity:.9 }

  .legend-card{ fill:rgba(10,14,20,.9); stroke:var(--grid); stroke-width:1; filter:drop-shadow(0 8px 16px rgba(0,0,0,.35)); rx:10; ry:10 }
  .legend-title{ fill:#9ad1ff; font-weight:600; font-size:12px }

  .tooltip{ position:absolute; pointer-events:none; opacity:0; background:#0d1320; color:#e8eef7; border:1px solid var(--grid); padding:8px 10px; font-size:12px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.25); transform:translate(-50%,-120%) }
</style>
</head>
<body>
<header>
  <h1>US Earthquakes — Interactive Map</h1>
  <div class="sub">Color = Depth, Size = Magnitude. Location accepts “AZ” or “Arizona”.</div>
</header>

<div class="layout">
  <aside class="sidebar">
    <div class="filters">

      <!-- Magnitude -->
      <div class="section">
        <div class="row">
          <div class="label">Magnitude</div>
          <div class="valuespan" id="magVals">—</div>
        </div>
        <div class="slider2">
          <input id="magMinR" class="lower" type="range" step="0.1">
          <input id="magMaxR" class="upper" type="range" step="0.1">
        </div>
        <div class="row values">
          <div class="valuebox">
            <span>Min</span><input id="magMinN" type="number" step="0.1">
            <span></span>
            <span>Max</span><input id="magMaxN" type="number" step="0.1">
          </div>
        </div>
      </div>

      <!-- Depth -->
      <div class="section">
        <div class="row">
          <div class="label">Depth (km)</div>
          <div class="valuespan" id="depthVals">—</div>
        </div>
        <div class="slider2">
          <input id="depthMinR" class="lower" type="range" step="10">
          <input id="depthMaxR" class="upper" type="range" step="10">
        </div>
        <div class="row values">
          <div class="valuebox">
            <span>Min</span><input id="depthMinN" type="number" step="10">
            <span></span>
            <span>Max</span><input id="depthMaxN" type="number" step="10">
          </div>
        </div>
        <div class="checkboxrow">
          <label><input id="includeNA" type="checkbox"> Include N/A depth</label>
        </div>
      </div>

      <!-- Year -->
      <div class="section">
        <div class="row">
          <div class="label">Year</div>
          <div class="valuespan" id="yearVals">—</div>
        </div>
        <div class="slider2">
          <input id="yearMinR" class="lower" type="range" step="1">
          <input id="yearMaxR" class="upper" type="range" step="1">
        </div>
        <div class="row values">
          <div class="valuebox">
            <span>Min</span><input id="yearMinN" type="number" step="1">
            <span></span>
            <span>Max</span><input id="yearMaxN" type="number" step="1">
          </div>
        </div>
      </div>

      <!-- Location -->
      <div class="section">
        <div class="row">
          <div class="label">Location</div>
          <div class="valuespan helper">Exact “City, ST” (AZ/Arizona)</div>
        </div>
        <div class="locbox">
          <input id="locInput" type="text" placeholder="Type: Phoenix, AZ or Phoenix, Arizona" autocomplete="off">
          <div id="locSuggest" class="loc-suggest"></div>
          <div class="helper">Shows up to 10 matches. Click to apply. Clear to show all.</div>
        </div>
      </div>

      <div class="section" style="padding-top:4px;">
        <div class="label" style="opacity:.85;">Tip: Click empty map area to reset zoom.</div>
      </div>

    </div>
  </aside>

  <div class="view">
    <svg id="svg" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="tooltip" id="tooltip"></div>
  </div>
</div>

<script>
(async function () {
  /* ---------------- State maps (abbr <-> full) ---------------- */
  const STATE_ABBR_TO_FULL = {
    AL:"Alabama", AK:"Alaska", AZ:"Arizona", AR:"Arkansas", CA:"California", CO:"Colorado",
    CT:"Connecticut", DE:"Delaware", FL:"Florida", GA:"Georgia", HI:"Hawaii", ID:"Idaho",
    IL:"Illinois", IN:"Indiana", IA:"Iowa", KS:"Kansas", KY:"Kentucky", LA:"Louisiana",
    ME:"Maine", MD:"Maryland", MA:"Massachusetts", MI:"Michigan", MN:"Minnesota",
    MS:"Mississippi", MO:"Missouri", MT:"Montana", NE:"Nebraska", NV:"Nevada",
    NH:"New Hampshire", NJ:"New Jersey", NM:"New Mexico", NY:"New York",
    NC:"North Carolina", ND:"North Dakota", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
    PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota",
    TN:"Tennessee", TX:"Texas", UT:"Utah", VT:"Vermont", VA:"Virginia", WA:"Washington",
    WV:"West Virginia", WI:"Wisconsin", WY:"Wyoming", DC:"District of Columbia",
    PR:"Puerto Rico", GU:"Guam", VI:"Virgin Islands", AS:"American Samoa", MP:"Northern Mariana Islands"
  };
  const STATE_FULL_TO_ABBR = Object.fromEntries(Object.entries(STATE_ABBR_TO_FULL).map(([k,v])=>[v.toLowerCase(), k]));
  /* ---------------------------------------------------------------- */

  const svg = d3.select("#svg");
  const zoomLayer = svg.append("g");
  const mapG = zoomLayer.append("g");
  const ptsG = zoomLayer.append("g");
  const legendG = svg.append("g");
  const tooltip = d3.select("#tooltip");

  function sizeSVG(){
    const r = document.querySelector(".view").getBoundingClientRect();
    svg.attr("viewBox", [0,0,r.width,r.height]);
    return { width:r.width, height:r.height };
  }
  let { width, height } = sizeSVG();
  window.addEventListener("resize", ()=>{ ({width,height}=sizeSVG()); drawLegend(); render(); });

  // Map
  const projection = d3.geoAlbersUsa().translate([width/2, height/2]).scale(Math.min(width,height)*1.2);
  const path = d3.geoPath(projection);
  const us = await fetch("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(r=>r.json());
  const states = topojson.feature(us, us.objects.states);
  const borders = topojson.mesh(us, us.objects.states, (a,b)=>a!==b);
  mapG.append("path").datum(states).attr("class","states").attr("d", path);
  mapG.append("path").datum(borders).attr("class","state-borders").attr("d", path);

  // Data
  const data = await d3.csv("us_earthquakes_m4.5.csv", d=>{
    const depth = (d.depth===""||d.depth==null)?null:+d.depth;
    const mag   = (d.mag===""  ||d.mag==null)?null:+d.mag;
    const lat=+d.latitude, lon=+d.longitude;
    const year = d.time ? new Date(d.time).getUTCFullYear() : null;
    return { time:d.time, year, place:d.place||"", region:d.region||"", depth, mag, lat, lon };
  });
  const points = data.filter(d => isFinite(d.lat) && isFinite(d.lon));

  // Helpers
  function normalizeStateToken(token){
    if(!token) return {abbr:"", full:""};
    const t = token.trim();
    if (STATE_ABBR_TO_FULL[t.toUpperCase()]) return { abbr:t.toUpperCase(), full: STATE_ABBR_TO_FULL[t.toUpperCase()] };
    const ab = STATE_FULL_TO_ABBR[t.toLowerCase()];
    if (ab) return { abbr:ab, full:STATE_ABBR_TO_FULL[ab] };
    return { abbr:t, full:t };
  }

  function cityStateFromPlace(d){
    const place = (d.place||"").trim();
    const region = (d.region||"").trim();

    let m = place.match(/of\s+([^,]+)\s*,\s*([A-Za-z.\s-]{2,})/i);
    if (m){
      const city = m[1].trim(); const st = normalizeStateToken(m[2]);
      return city && st.abbr ? {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full} : null;
    }
    m = place.match(/^\s*([^,]+)\s*,\s*([A-Za-z.\s-]{2,})\s*$/);
    if (m){
      const city = m[1].trim(); const st = normalizeStateToken(m[2]);
      return city && st.abbr ? {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full} : null;
    }
    if (region){
      const parts = region.split(",").map(s=>s.trim());
      if (parts.length===2){
        const city = parts[0]; const st = normalizeStateToken(parts[1]);
        return { label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full };
      } else if (parts.length===1){
        const st = normalizeStateToken(parts[0]);
        return { label: st.abbr, city:"", stAbbr:st.abbr, stFull:st.full };
      }
    }
    const tail = place.split(',').map(s=>s.trim());
    if (tail.length>=2){
      const st = normalizeStateToken(tail[tail.length-1]);
      const city = tail[tail.length-2].replace(/.*of\s+/i,'').trim();
      if (city && st.abbr) return {label:`${city}, ${st.abbr}`, city, stAbbr:st.abbr, stFull:st.full};
    }
    return {label:"", city:"", stAbbr:"", stFull:""};
  }

  points.forEach(d => {
    const cs = cityStateFromPlace(d);
    d.locLabel = cs.label;
    d.locCity  = cs.city;
    d.locStAbbr= cs.stAbbr;
    d.locStFull= cs.stFull;
  });

function displayLabel(d){
  // Always prefer "City, ST". If no city, just "ST".
  if (d.locCity && d.locStAbbr) return `${d.locCity}, ${d.locStAbbr}`;
  if (d.locStAbbr) return d.locStAbbr;
  // Fallbacks if we couldn't parse a state (rare/territories)
  if (d.locLabel) return d.locLabel;         // already "City, ST" form if present
  if (d.region)   return d.region;           // last resort
  return "Location";
}

  // Build unique locations with search forms and state info
  const locMap = new Map(); // label -> {label,count,forms:Set, stAbbr, stFull}
  for (const d of points){
    if (!d.locLabel) continue;
    const key = d.locLabel;
    const labelLower = key.toLowerCase();
    const withFull = d.locCity ? `${d.locCity}, ${d.locStFull}` : d.locStFull;
    const withFullLower = (withFull || key).toLowerCase();

    if (!locMap.has(key)){
      locMap.set(key, { label:key, count:1, forms:new Set([labelLower, withFullLower]), stAbbr:d.locStAbbr, stFull:d.locStFull });
    } else {
      const e = locMap.get(key);
      e.count++;
      e.forms.add(labelLower);
      e.forms.add(withFullLower);
    }
  }
  const locEntries = Array.from(locMap.values())
    .map(e => ({ label:e.label, count:e.count, forms:Array.from(e.forms), stAbbr:e.stAbbr, stFull:e.stFull }))
    .sort((a,b)=> d3.descending(a.count,b.count) || d3.ascending(a.label,b.label));

  // Domains
  const depthVals = points.map(d=>d.depth).filter(v=>v!=null && isFinite(v));
  const depthExt  = d3.extent(depthVals.length ? depthVals : [0,700]);
  const dDomMin   = Math.max(0, Math.floor((depthExt[0] ?? 0)));
  const dDomMax   = Math.min(700, Math.ceil((depthExt[1] ?? 700)));
  const magVals = points.map(d=>d.mag).filter(v=>v!=null && isFinite(v));
  const magDom  = d3.extent(magVals.length ? magVals : [4.5,8]);
  const yearVals = points.map(d=>d.year).filter(y=>y!=null && isFinite(y));
  const yearDom  = d3.extent(yearVals.length ? yearVals : [1950, 2025]);

  const color = d3.scaleSequential([dDomMin, dDomMax], d3.interpolateTurbo);
  const size  = d3.scaleSqrt().domain(magDom).range([1.8, 11]);

  // UI state
  let magRange=[magDom[0],magDom[1]], depthRange=[dDomMin,dDomMax], yearRange=[yearDom[0],yearDom[1]];
  let locExact = "";

  // Dual sliders
  function initDual({domain,step,ids,onChange,labelElId}){
    const [loR,hiR,loN,hiN]=[ids.lowerRange,ids.upperRange,ids.lowerNum,ids.upperNum].map(id=>document.getElementById(id));
    const label=document.getElementById(labelElId);
    [loR.min,hiR.min,loN.min,hiN.min]=[domain[0],domain[0],domain[0],domain[0]];
    [loR.max,hiR.max,loN.max,hiN.max]=[domain[1],domain[1],domain[1],domain[1]];
    [loR.step,hiR.step,loN.step,hiN.step]=[step,step,step,step];
    const clamp=v=>Math.min(domain[1],Math.max(domain[0],step>=1?Math.round(v/step)*step:Math.round(v*10)/10));
    const paint=(a,b)=>{const p=v=>100*(v-domain[0])/(domain[1]-domain[0]);loR.style.background=`linear-gradient(to right,#dfe8f6 ${p(domain[0])}%,var(--accent) ${p(a)}%,var(--accent) ${p(b)}%,#dfe8f6 ${p(domain[1])}%)`;};
    const sync=(a,b,notify=true)=>{a=clamp(a);b=clamp(b);if(a>b)[a,b]=[b,a];[loR.value,hiR.value,loN.value,hiN.value]=[a,b,a,b];paint(a,b);if(label){const f=step===0.1?x=>(+x).toFixed(1):x=>x;label.textContent=`${f(a)} – ${f(b)}`;}if(notify)onChange([a,b]);};
    loR.oninput=()=>sync(+loR.value,+hiR.value);
    hiR.oninput=()=>sync(+loR.value,+hiR.value);
    loN.onchange=()=>sync(+loN.value,+hiN.value);
    hiN.onchange=()=>sync(+loN.value,+hiN.value);
    sync(domain[0],domain[1]);
  }
  initDual({ domain:magDom, step:0.1, ids:{lowerRange:'magMinR',upperRange:'magMaxR',lowerNum:'magMinN',upperNum:'magMaxN'}, labelElId:'magVals', onChange:r=>{ magRange=r; render(); }});
  initDual({ domain:[dDomMin,dDomMax], step:10, ids:{lowerRange:'depthMinR',upperRange:'depthMaxR',lowerNum:'depthMinN',upperNum:'depthMaxN'}, labelElId:'depthVals', onChange:r=>{ depthRange=r; render(); }});
  initDual({ domain:yearDom, step:1, ids:{lowerRange:'yearMinR',upperRange:'yearMaxR',lowerNum:'yearMinN',upperNum:'yearMaxN'}, labelElId:'yearVals', onChange:r=>{ yearRange=r; render(); }});

  /* ---------------- Autocomplete with state-aware matching ---------------- */
  const locInput = document.getElementById("locInput");
  const locPanel = document.getElementById("locSuggest");
  let activeIdx = -1;

  function closePanel(){ locPanel.style.display = "none"; activeIdx=-1; }
  function openPanel(){ if (locPanel.childElementCount>0){ locPanel.style.display = "block"; } }

  function canonQuery(q){
    const parts = q.split(",").map(s=>s.trim());
    if (parts.length>=2){
      const stateTok = parts.pop();
      const ab = STATE_ABBR_TO_FULL[stateTok.toUpperCase()] ? stateTok.toUpperCase()
               : (STATE_FULL_TO_ABBR[stateTok.toLowerCase()] || "");
      return parts.join(", ") + (ab ? (", " + ab) : "");
    }
    return q;
  }

  function renderSuggestions(qRaw){
    const qTrim = (qRaw||"").trim();
    const qLower = qTrim.toLowerCase();
    locPanel.innerHTML = "";
    if (!qTrim){ closePanel(); return; }

    // Detect if query is purely a state token (abbr or full)
    const abbrOnly = STATE_ABBR_TO_FULL[qTrim.toUpperCase()] ? qTrim.toUpperCase() : "";
    const fullOnlyAbbr = STATE_FULL_TO_ABBR[qLower] || "";

    let results = [];

    if (abbrOnly || fullOnlyAbbr){
      const ab = abbrOnly || fullOnlyAbbr; // USPS code
      results = locEntries.filter(e => e.stAbbr === ab).slice(0, 10);
    } else {
      // General query
      const qCanon = canonQuery(qTrim).toLowerCase();

      const starts = [];
      const contains = [];

      for (const e of locEntries){
        const city = e.label.split(",")[0].trim().toLowerCase();
        const stAb = e.stAbbr.toLowerCase();
        const stFull = (e.stFull||"").toLowerCase();

        const startsMatch = city.startsWith(qLower) ||
                            (`${city}, ${stAb}`).startsWith(qCanon) ||
                            (`${city}, ${stFull}`).startsWith(qLower);

        const includesMatch = (!startsMatch) && (
          city.includes(qLower) ||
          (", " + stAb).includes(", " + qLower) ||
          (", " + stFull).includes(", " + qLower)
        );

        if (startsMatch) starts.push(e);
        else if (includesMatch) contains.push(e);

        if (starts.length >= 10) break;
      }
      results = starts.concat(contains).slice(0,10);
    }

    if (!results.length){ closePanel(); return; }

    for (const {label,count} of results){
      const div = document.createElement("div");
      div.className = "loc-item";
      div.textContent = label;
      div.title = `${label} (${count})`;
      div.addEventListener("mousedown", (e)=>{ e.preventDefault(); applyLocation(label); });
      locPanel.appendChild(div);
    }
    activeIdx = -1;
    openPanel();
  }

  function applyLocation(label){
    locInput.value = label;
    locExact = label;
    closePanel();
    render();
  }

  locInput.addEventListener("input", (e)=>{
    const v = e.target.value;
    if (!v){ locExact = ""; closePanel(); render(); return; }
    renderSuggestions(v);
  });

  locInput.addEventListener("keydown", (e)=>{
    const items = Array.from(locPanel.children);
    if (e.key === "ArrowDown" && items.length){
      e.preventDefault();
      activeIdx = Math.min(items.length-1, activeIdx+1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
      if (activeIdx>=0) items[activeIdx].scrollIntoView({block:"nearest"});
    } else if (e.key === "ArrowUp" && items.length){
      e.preventDefault();
      activeIdx = Math.max(-1, activeIdx-1);
      items.forEach((el,i)=> el.classList.toggle("active", i===activeIdx));
    } else if (e.key === "Enter"){
      if (activeIdx>=0 && items[activeIdx]){
        e.preventDefault();
        applyLocation(items[activeIdx].textContent);
      } else {
        const typed = locInput.value.trim();
        const typedCanon = canonQuery(typed);
        if (locMap.has(typedCanon)) { applyLocation(typedCanon); }
        else if (locMap.has(typed)) { applyLocation(typed); }
        else { locExact=""; closePanel(); render(); }
      }
    } else if (e.key === "Escape"){
      closePanel();
    }
  });

  document.addEventListener("click", (e)=>{
    if (!document.querySelector(".locbox").contains(e.target)) closePanel();
  });
  /* ------------------------------------------------------------------------ */

  // Legend (compact)
  function drawLegend(){
    legendG.selectAll("*").remove();
    const pad = 10;
    const cardW = Math.min(260, Math.max(220, width * 0.22));
    const depthBarH = 12;

    const sizeLegend = d3.scaleSqrt().domain(size.domain()).range([3, 9]);
    const maxR = sizeLegend(size.domain()[1]);

    const cardH = 26 + depthBarH + 12 + 16 + 8 + 26 + maxR + 12 + 8;
    const x0 = width - cardW - 12;
    const y0 = height - cardH - 12;

    legendG.append("rect").attr("class","legend-card").attr("x",x0).attr("y",y0).attr("width",cardW).attr("height",cardH);
    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",y0+18).text("Depth (km)");

    const barW = cardW - pad*2;
    const gradId = "depthGrad";
    const defs = legendG.append("defs");
    const grad = defs.append("linearGradient").attr("id",gradId).attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");
    const [d0,d1] = color.domain();
    for (let i=0;i<=12;i++){ const t=i/12, val=d0+t*(d1-d0); grad.append("stop").attr("offset",`${t*100}%`).attr("stop-color", color(val)); }
    legendG.append("rect").attr("x",x0+pad).attr("y",y0+26).attr("width",barW).attr("height",depthBarH).attr("rx",6).attr("ry",6).attr("fill",`url(#${gradId})`).attr("stroke","#243142");

    const tickY = y0 + 26 + depthBarH + 12;
    [d0, Math.round((d0+d1)/2), d1].forEach((t,i)=>{
      const tx = x0 + pad + (barW * i/2);
      legendG.append("text").attr("x",tx).attr("y",tickY).attr("text-anchor", i===0?'start':i===2?'end':'middle').attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6').attr("font-size",11).text(t);
    });

    const magTitleY = tickY + 8 + 16;
    legendG.append("text").attr("class","legend-title").attr("x",x0+pad).attr("y",magTitleY).text("Magnitude");

    const mags = [size.domain()[0], (size.domain()[0]+size.domain()[1])/2, size.domain()[1]].map(v=>+v.toFixed(1));
    const cxLeft  = x0 + pad + maxR + 4;
    const cxRight = x0 + cardW - pad - maxR - 4;
    const gap = (cxRight - cxLeft) / (mags.length - 1);
    const circlesY = magTitleY + 10 + 16;
    mags.forEach((m,i)=>{
      const cx = cxLeft + i*gap, r = sizeLegend(m);
      legendG.append("circle").attr("cx",cx).attr("cy",circlesY).attr("r",r).attr("fill","#e6e6e6").attr("fill-opacity",.9).attr("stroke","#000").attr("stroke-opacity",.4);
      legendG.append("text").attr("x",cx).attr("y",circlesY + r + 12).attr("text-anchor","middle").attr("fill", getComputedStyle(document.documentElement).getPropertyValue('--muted')||'#9fb0c6').attr("font-size",11).text(m);
    });
  }

  function render(){
    const allowNA = document.getElementById("includeNA").checked;

    const filtered = points.filter(d=>{
      const magOK   = (d.mag  != null && d.mag  >= magRange[0]   && d.mag  <= magRange[1]);
      const yearOK  = (d.year != null && d.year >= yearRange[0]  && d.year <= yearRange[1]);
      const depthOK = d.depth == null ? allowNA : (d.depth >= depthRange[0] && d.depth <= depthRange[1]);
      const locOK   = !locExact ? true : ((d.locLabel||"").toLowerCase() === locExact.toLowerCase());
      return magOK && yearOK && depthOK && locOK;
    });

    const sel = ptsG.selectAll("circle.quake").data(filtered, (d,i)=>d.time+"|"+i);

    function tipHTML(d){
      // Standardize to “City, ST” or just “ST”. Fallback to original place/region for non-US.
      const locText = d.locStAbbr
        ? (d.locCity ? `${d.locCity}, ${d.locStAbbr}` : d.locStAbbr)
        : (d.place || d.region || "Location");
      return `
        <div><b>${d.mag?.toFixed(1) ?? "M?"}</b> — <span style="color:var(--muted)">${displayLabel(d)}</span></div>
        <div>Depth: <b>${d.depth==null ? "N/A" : Math.round(d.depth)+" km"}</b></div>
        <div style="color:var(--muted)">${d.time ? new Date(d.time).toUTCString() : ""}</div>
      `;
    }

    sel.enter().append("circle")
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      })
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("fill-opacity", .85)
      .on("mousemove", (event, d) => {
        const [x,y] = d3.pointer(event, document.querySelector(".view"));
        tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(tipHTML(d));
      })
      .on("mouseleave", ()=> tooltip.style("opacity", 0));

    sel
      .attr("r", d => size(d.mag ?? magDom[0]))
      .attr("fill", d => d.depth==null ? "#9aa0a6" : color(d.depth))
      .attr("class", d => "quake" + (d.depth==null ? " nodata" : ""))
      .attr("transform", d => {
        const p = projection([d.lon, d.lat]);
        return p ? `translate(${p[0]},${p[1]})` : "translate(-999,-999)";
      })
      .on("mousemove", (event, d) => {
        const [x,y] = d3.pointer(event, document.querySelector(".view"));
        tooltip.style("left",(x+12)+"px").style("top",(y-12)+"px").style("opacity",1).html(tipHTML(d));
      });

    sel.exit().remove();
  }

  drawLegend();
  render();

  // Zoom
  const zoom = d3.zoom().scaleExtent([0.9, 8]).on("zoom", (ev)=> {
    zoomLayer.attr("transform", ev.transform);
  });
  svg.call(zoom).on("click", (e)=>{
    if (e.target === svg.node()) svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
  });

  document.getElementById("includeNA").addEventListener("change", render);
})();
</script>
</body>
</html>
